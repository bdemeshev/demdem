---
title: "dem_regional"
output: pdf_document
lang: russian
---

```{r, message=FALSE, warning=FALSE}
library("ggplot2")
library("knitr")
library("MCMCpack")
library("pander")
library("dplyr")
library("MHadaptive")
```


загружаем данные
```{r}
h <- read.csv("./data/regional_data.csv")
W <- read.csv("./data/Wb.csv", header=FALSE)
W <- as.matrix(W)
n <- nrow(h)
```

Переименуем для удобства:
```{r}
h <- dplyr::rename(h, y_star = Y, Wy_star = WbY, y_0 = ln.gdppercappp., region = X) %>% 
  dplyr::select(-number)
glimpse(h)
```


Априорные распределения:

1. $\rho \sim U[-1;1]$

2. $\phi \sim $ diffuse

3. $\sigma^2_{\varepsilon} \sim $ standard diffuse ???

4. $q \sim \Gamma(a_q, b_q)$

5. $v_i^{-1} | q \sim iid \chi^2(q)$, $v_i$ --- diagonal of $V$

6. $Var(\varepsilon) = \sigma^2_{\varepsilon} V$ ?

Упрощенная модель 
\[
y^* = \rho Wy^* + \alpha i + \beta y_0 + X\gamma + \varepsilon
\]

Полная из статьи
\[
y^* = \rho Wy^* + \alpha i + \beta y_0 +\theta Wy_0 + X\gamma + WX\xi +  \varepsilon
\]



Упрощения: $\theta=0$, $\xi=0$


```{r}
X <- as.matrix(h[,5:17])
WX <- W %*% X
Wy_0 <- W %*% h$y_0
Z <- cbind( rep(1, n), h$y_0, Wy_0, X, WX) # original: [ ι Yo WYo X WX]
# Z <- cbind( rep(1, n), h$y_0, Wy_0, X, WX )
n
m <- ncol(X)
```

Параметры:

\[
(\rho, \alpha, \beta, \theta, \gamma, \xi, \sigma^2, v)
\]


$\xi, \gamma \in R^{`r ncol(X)`}$, $v\in R^{`r n`}$


Изначальные значения параметров

```{r, results='asis'}
model_0 <- lm(h$y_star ~ h$Wy_star + h$y_0 + Wy_0 + X + WX)
coefs <- coef(model_0)
pander(model_0)
```

```{r}
# y^* = \rho Wy^* + \alpha i + \beta y_0 +\theta Wy_0 + X\gamma + WX\xi +  \varepsilon
# (\rho, \alpha, \beta, \theta, \gamma, \xi, \sigma^2, v)
rho_init <- coefs[2]
alpha_init <- coefs[1]
v_init <- rep(1, n)
btgxi <- coefs[-2:-1]
s2_init <- deviance(model_0)/df.residual(model_0)
pars_init <- c(rho_init, alpha_init, btgxi, s2_init, v_init)
names(pars_init)[1:4] <- c("rho", "alpha", "beta", "theta")
names(pars_init)[5+2*m] <- "s2"
names(pars_init)[(6+2*m):(5+2*m+n)] <- paste0(rep("v",n),1:n)
```



MCMC

```{r}
n_sim <- 10
n_burnin <- 0.1*n_sim
n_mh_iters <- 10000
pars <- matrix(0, nrow=n_sim, ncol=length(pars_init))
pars[1, ] <- pars_init
colnames(pars) <- names(pars_init)
```


go-go-go

```{r}
# (\rho, \alpha, \beta, \theta, \gamma, \xi, \sigma^2, v)
for (j in 2:n_sim) {
  # good 
  rho <- pars[j-1, 1]
  alpha <- pars[j-1, 2]
  beta <- pars[j-1, 3]
  theta <- pars[j-1, 4]
  gamma <- pars[j-1, 5:(4+m)]
  xi <- pars[j-1, (5+m):(4+2*m)]
  s2 <- pars[j-1, 5+2*m]
  v <- pars[j-1, (6+2*m):(5+2*m+n)]
  V <- diag(v)
  
  
  
  # step a
  Vinv <- solve(V)
  ZtVinv <- t(Z) %*% Vinv
  y_tilde <- y - rho*W %*% y ### y?????
  r <- s2^(-1)*ZtVinv %*% y_tilde
  S <- s2*solve(ZtVinv %*% Z)
  
  phi <- rmvnorm(1, r, S) #  ??? S is variance matrix ???
  
  # step b
  e <- y_star - rho*Wy_star - alpha - beta*y_0 - theta*Wy_0 - WX %*% xi
  etVinve <- t(e) %*% Vinv %*% e
  s2 <- rinvgamma(1, n/2, etVinve/2) # e ????
  
  # check parameters!!!
  
  # step c
  s2ev <- rchisq(n, df=q+1) # q in pars!!!
  v <- s2*e^2/s2ev # !!!!! minus sign in formula!!!!
  V <- diag(v)
  
  # step d
  etVinve <- t(e) %*% Vinv %*% e
  
  
  # step e
  
  
  
  # save
  s2 -> pars[j-1, 5]
  rho -> pars[j-1, 1]
  alpha -> pars[j-1, 2]
  beta -> pars[j-1, 3]
  theta -> pars[j-1, 4]
  gamma -> pars[j-1, 5:(4+m)]
  xi -> pars[j-1, (5+m):(4+2*m)]
  s2 -> pars[j-1, 5+2*m]
  diag(V) -> pars[j-1, (6+2*m):(5+2*m+n)]
}
```


```{r, "testing MH from MHadaptive", eval=FALSE}
f <- function(x) {
  return(log(dnorm(x)))
}
mcmc_out <- Metro_Hastings(f, pars = 0, iterations = 1000)
tail(mcmc_out$trace,1)
```


